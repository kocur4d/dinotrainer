<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <title>T-Rex Game.</title>
        <style>/* Copyright 2014 The Chromium Authors. All rights reserved.
            Use of this source code is governed by a BSD-style license that can be
            found in the LICENSE file. */
            a {
            color: #585858;
            }
            body {
            background-color: #f7f7f7;
            color: #585858;
            font-size: 125%;
            font-family: Trebuchet MS,Lucida Grande,Lucida Sans Unicode,Lucida Sans,Tahoma,sans-serif;
            }
            body.safe-browsing {
            background-color: rgb(206, 52, 38);
            color: white;
            }
            button {
            background: rgb(76, 142, 250);
            border: 0;
            border-radius: 2px;
            box-sizing: border-box;
            color: #fff;
            cursor: pointer;
            float: right;
            font-size: .875em;
            height: 36px;
            margin: -6px 0 0;
            padding: 8px 24px;
            transition: box-shadow 200ms cubic-bezier(0.4, 0, 0.2, 1);
            }
            [dir='rtl'] button {
            float: left;
            }
            button:active {
            background: rgb(50, 102, 213);
            outline: 0;
            }
            button:hover {
            box-shadow: 0 1px 3px rgba(0, 0, 0, .50);
            }
            .debugging-content {
            line-height: 1em;
            margin-bottom: 0;
            margin-top: 0;
            }
            .debugging-title {
            font-weight: bold;
            }
            #details {
            color: #696969;
            margin: 45px 0 50px;
            }
            #details p:not(:first-of-type) {
            margin-top: 20px;
            }
            #error-code {
            color: black;
            opacity: .35;
            text-transform: uppercase;
            }
            #error-debugging-info {
            font-size: 0.8em;
            }
            h1 {
            -webkit-margin-after: 16px;
            color: #585858;
            font-size: 1.6em;
            font-weight: normal;
            line-height: 1.25em;
            }
            h2 {
            font-size: 1.2em;
            font-weight: normal;
            }
            .hidden {
            display: none;
            }
            .icon {
            background-repeat: no-repeat;
            background-size: 100%;
            height: 72px;
            margin: 0 0 40px;
            width: 72px;
            }
            input[type=checkbox] {
            visibility: hidden;
            }
            .interstitial-wrapper {
            box-sizing: border-box;
            font-size: 1em;
            line-height: 1.6em;
            margin: 50px auto 0;
            max-width: 600px;
            width: 100%;
            }
            #malware-opt-in {
            font-size: .875em;
            margin-top: 39px;
            }
            .nav-wrapper {
            margin-top: 51px;
            }
            .nav-wrapper::after {
            clear: both;
            content: '';
            display: table;
            width: 100%;
            }
            #opt-in-label {
            -webkit-margin-start: 32px;
            }
            .safe-browsing :-webkit-any(
            a, #details, #details-button, h1, h2, p, .small-link) {
            color: white;
            }
            .safe-browsing button {
            background-color: rgb(206, 52, 38);
            border: 1px solid white;
            }
            .safe-browsing button:active {
            background-color: rgb(206, 52, 38);
            border-color: rgba(255, 255, 255, .6);
            }
            .safe-browsing button:hover {
            box-shadow: 0 2px 3px rgba(0, 0, 0, .5);
            }
            .safe-browsing .icon {
            background-image: -webkit-image-set(
            url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAMAAABiM0N1AAABoVBMVEX///+Li4v////////y8vL09PT99fTbRDfXzMzt7e3v7+/s7Ozy8vLw8PDu7u799PPSQTXx8fHZdGv19fX09PTm5ubbV0zXzczgW1Dd3d3c3Nzjb2Th4eHr6+vl5eXp6enZ2dng4OD29vbz8/PYYFXZV0zaYVbjbWP219TRQTTXdGz43Nn++/rib2T////b29vTQjXaYVf66ObngXjjbmTq6ura2trngHf76Ofk19bX19fe3t7o6Oji4uLk5OTeU0f119TYQzbZQzbWQjbXQzbZRDfaRDfn5+fbV0vj4+PVQjXf39/Y2Njgcmney8rqk4zdysn43drcysjcUETa1tbadGvaV0vaWEzZYVbibmXc2NjfzMvi0M7mfHPYYVbhzszd2dnZx8XieXDkc2nWX1Xacmne2trZdGzbcWjj0c/XTUHX1NPVX1Xg3NzYdGvYXFHZ1dXWTUHgzczUX1Xh3d3XdWzWXFHaVkvXxcTVTEHhbmXTXlXi3t7ayMbVXFLgbmXUTEDXYFXSXlTXzMvk4ODUXFHWbGPWzMvk4eHZioP39/f9Ro5BAAAABnRSTlMAAOQk5ye8yu+CAAACRklEQVR4XrXWRZPbUBSEUWdmIpl5mJmZg8zMzMzMzPCr43isNqif76u6lW+nuzgrtUqB/1ptzUSVamrVDiS1A0ntQFI7kNQOJLUDSe1AUjuQ1A4ktQNJ70DSO5D0DiS9A0nvQIKjlOAoJThqyewsXZ1hQOL8YZNkcJrcJiIlBt2No0zKQSbHJVJiznW5BIg4kMocSDIEBxKcwvkoJAE6uMJAguO13xIaWyyRiDPdGGGQJBFnzb4Qh2Qp0VrmdHXFCSRKxFmYDAsQpNkSiTgtLZAAydIgcZqbYwQSJOqs3QsJkCRxp7s7RSBBok5bW5RAgkSd9bujIoS3AA0QZ0NHrx3ktLro5SvidNRnAUkO2nWZOPU7s4BEB9J74qzrzACSHNRwhDid8xlAogPpEHHa23sIxJyB60XpAHEioT9myBnf4XWq8W4aDw1niROKA/I7270u5HbxKI3Hk0+IEzZBzuktXn35XRw7jsOJi34nZoCcN5u9+gq7OJPGqf+czzFAzsdtXp+xi0tpHPtvVzopDl3Z6nUtWNzXjZs436p0DNDQnT0r3QuW7vT+g8L54XKlEzX8RAw9nvrX02D53p89z59f+J0602/NptfJZPKt52AX70Zy5w/EWR0wSp+Gv3z1f3++jQx/545Z+vGTfcd+/eYOJFIEDtkpccxSyNqRpLitI0uWjiyFLR1ZignOqoC1VN0BJEupag4gK8nsALKToiYHkK3Uyx0CiRJ3ANlLWe4AspcyxKGQLHEHkL3UQxwKyRJxCKTtLyVXfw+a8JTgAAAAAElFTkSuQmCC) 1x,
            url(data:image/png;base64,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) 2x);
            }
            .small-link {
            color: #696969;
            font-size: .875em;
            }
            .ssl .icon {
            background-image: -webkit-image-set(
            url(data:image/png;base64,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) 1x,
            url(data:image/png;base64,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) 2x);
            }
            .styled-checkbox {
            float: left;
            height: 16px;
            margin-top: .36em;
            position: relative;
            width: 16px;
            }
            [dir='rtl'] .styled-checkbox {
            float: right;
            }
            .styled-checkbox label {
            background: transparent;
            border: white solid 1px;
            border-radius: 2px;
            height: 14px;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            width: 14px;
            }
            .styled-checkbox label::after {
            background: transparent;
            border: 2px solid white;
            border-right-width: 0;
            border-top-width: 0;
            content: '';
            height: 4px;
            left: 2px;
            opacity: 0.3;
            position: absolute;
            top: 3px;
            transform: rotate(-45deg);
            width: 9px;
            }
            .styled-checkbox input[type=checkbox]:checked + label::after {
            opacity: 1;
            }
            @media (max-width: 700px) {
            .interstitial-wrapper {
            padding: 0 10%;
            }
            }
            @media (max-height: 600px) {
            .interstitial-wrapper {
            margin-top: 5px;
            }
            }
            @media (max-width: 400px) {
            button,
            [dir='rtl'] button {
            float: none;
            font-size: 1em;
            width: 100%;
            }
            #details {
            margin: 20px 0 20px 0;
            }
            #details p:not(:first-of-type) {
            margin-top: 10px;
            }
            #details-button {
            display: block;
            padding-top: 14px;
            text-align: center;
            width: 100%;
            }
            .interstitial-wrapper {
            padding: 0 5%;
            }
            #malware-opt-in {
            margin-top: 24px;
            }
            .nav-wrapper {
            margin-top: 30px;
            }
            .small-link {
            font-size: 1em;
            }
            }
        </style>
        <style>/* Copyright 2013 The Chromium Authors. All rights reserved.
            * Use of this source code is governed by a BSD-style license that can be
            * found in the LICENSE file. */
            /* Don't use the main frame div when the error is in a subframe. */
            html[subframe] #main-frame-error {
            display: none;
            }
            /* Don't use the subframe error div when the error is in a main frame. */
            html:not([subframe]) #sub-frame-error {
            display: none;
            }
            #diagnose-button {
            -webkit-margin-start: 0;
            float: none;
            margin-bottom: 10px;
            margin-top: 20px;
            }
            h1 {
            -webkit-margin-before: 0;
            }
            h2 {
            color: #666;
            font-size: 1.2em;
            font-weight: normal;
            margin: 10px 0;
            }
            a {
            color: rgb(17, 85, 204);
            text-decoration: none;
            }
            .icon {
            -webkit-user-select: none;
            }
            .icon-generic {
            /**
            * Can't access chrome://theme/IDR_ERROR_NETWORK_GENERIC from an untrusted
            * renderer process, so embed the resource manually.
            */
            content: -webkit-image-set(
            url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAAyCAAAAADkGq1yAAAAAnRSTlMA/1uRIrUAAABLSURBVHhe7dOxDQAgCERRdrza/ScwscNYSKIhWAror9+VR7BjKZbkrSpKeA45K8PQuoYqcUNKbmUzpNkD8kvM/ErlkVFk8necCyU7IotT35DVJRIAAAAASUVORK5CYII=') 1x,
            url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFIAAABkCAAAAAAwZDj3AAAAAnRSTlMA/1uRIrUAAABiSURBVHhe7cy7CYAwFABAd8z+HyewskkTW+EFA3kgSu4GuK2ktI71SqWyjeyxirlS2aeMQczfKcuNUjny/1KpPCbKjA+WSqVSqVQqawmy5TlZKpVPQciVSuUEpVKZtVypVF5DHE3/NzR+1AAAAABJRU5ErkJggg==') 2x);
            height: 50px;
            padding-top: 20px;
            width: 41px;
            }
            .icon-offline {
            content: -webkit-image-set(
            url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAvAgMAAADlfsA8AAAADFBMVEX39/f////39/dTU1NOmoBdAAAAAnRSTlMAAHaTzTgAAAB6SURBVHherc2xDUIxDIThE6UbVmEZ9nN9TUZgJWo3Ju8UhGIrHX/1FScdnr82K+PMoZizbozLsfw+OP9mkpvNARuabB6OG6fIZr4uozi4noqTYrcKHoxi63ZodLBG0a0R0c2M5Uw5Z3rzoavqwNf3CGybKH4gYXTq6wPqOghb2tvIFQAAAABJRU5ErkJggg==') 1x,
            url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAABeAgMAAADaoju6AAAADFBMVEX39/f////39/dTU1NOmoBdAAAAAnRSTlMAAHaTzTgAAACDSURBVHhe7dIhDgQhAEPR6jV7urnkN3PEbkIIICCQSdfNl8/UVNe0DA/R0p7BtTzjFkesLO8nX6YUYpj8IcO48Ie+GGa4XSqYYwO4lWUPSpjH4I8s5Vg8Z7RhkeeZE2fRNc/Y5oRtu7NrC26bCKNWktEp2xueT5on/F2yLQlAQGWt+AcZixZ9AfIcYgAAAABJRU5ErkJggg==') 2x);
            height: 47px;
            margin: 0 0 40px;
            position: relative;
            width: 44px;
            }
            #content-top {
            margin: 20px;
            }
            #help-box-outer {
            -webkit-transition: height ease-in 218ms;
            overflow: hidden;
            }
            #help-box-inner {
            background-color: #f9f9f9;
            border-top: 1px solid #EEE;
            color: #444;
            padding: 20px;
            text-align: start;
            }
            #suggestion {
            margin-top: 15px;
            }
            #short-suggestion {
            margin-top: 5px;
            }
            #sub-frame-error-details {
            color: #8F8F8F;
            /* Not done on mobile for performance reasons. */
            text-shadow: 0 1px 0 rgba(255,255,255,0.3);
            }
            [jscontent=failedUrl] {
            overflow-wrap: break-word;
            }
            #search-container {
            /* Prevents a space between controls. */
            display: flex;
            margin-top: 20px;
            }
            #search-box {
            border: 1px solid #cdcdcd;
            flex-grow: 1;
            font-size: 16px;
            height: 26px;
            margin-right: 0;
            padding: 1px 9px;
            }
            #search-box:focus {
            border: 1px solid rgb(93, 154, 255);
            outline: none;
            }
            #search-button {
            border: none;
            border-bottom-left-radius: 0;
            border-top-left-radius: 0;
            box-shadow: none;
            display: flex;
            height: 30px;
            margin: 0;
            padding: 0;
            width: 60px;
            }
            #search-image {
            content:
            -webkit-image-set(
            url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAQAAAB+HTb/AAAArElEQVR4Xn3NsUoCUBzG0XvB3U0chR4geo5qihpt6gkCx0bXFsMERWj2KWqIanAvmlUUoQapwU6g4l8H5bd9Z/iSPS0hu/RqZqrncBuzLl7U3Rn4cSpQFTeroejJl1Lgs7f4ceDPdeBMXYp86gaONYJkY83AnqHiGk9wHnjk16PKgo5N9BUCkzPf5j6M0PfuVg5MymoetFwoaKAlB26WdXAvJ7u5mezitqtkT//7Sv/u96CaLQAAAABJRU5ErkJggg==') 1x,
            url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAeCAQAAACVzLYUAAABYElEQVR4Xr3VMUuVURzH8XO98jgkGikENkRD0KRGDUVDQy0h2SiC4IuIiktL4AvQt1CDBJUJwo1KXXS6cWdHw7tcjWwoC5Hrx+UZgnNO5CXiO/75jD/+QZf9MzjskVU7DrU1zRv9G9ir5hsA4Nii83+GA9ZI1nI1D6tWAE1TRlQMuuuFDthzMQefgo4nKr+f3dIGDdUUHPYD1ISoMQdgJgUfgqaKEOcxWE/BVTArJBvwC0cGY7gNLgiZNsD1GP4EPVn4EtyLYRuczcJ34HYMP4E7GdajDS7FcB48z8AJ8FmI4TjouBkzZ2yBuRQMlsButIZ+dfDVUBqOaIHvavpLVHXfFmAqv45r9gEHNr3y3hcAfLSgSMPgiiZR+6Z9AMuKNAwqpjUcA2h55pxgAfBWkYRlQ254YMJloaxPHbCkiGCymL5RlLA7GnRDXyuC7uhicLoKdRyaDE5Pl00K//93nABqPgBDK8sfWgAAAABJRU5ErkJggg==') 2x);
            margin: auto;
            }
            .hidden {
            display: none;
            }
            .suggestions {
            margin-top: 18px;
            }
            .suggestion-header {
            font-weight: bold;
            margin-bottom: 4px;
            }
            .suggestion-body {
            color: #777;
            }
            .error-code {
            color: #A0A0A0;
            margin-top: 15px;
            }
            /* Increase line height at higher resolutions. */
            @media (min-width: 641px) and (min-height: 641px) {
            #help-box-inner {
            line-height: 18px;
            }
            }
            /* Decrease padding at low sizes. */
            @media (max-width: 640px), (max-height: 640px) {
            body {
            margin: 15px;
            }
            h1 {
            margin: 10px 0 15px;
            }
            #content-top {
            margin: 15px;
            }
            #help-box-inner {
            padding: 20px;
            }
            .suggestions {
            margin-top: 10px;
            }
            .suggestion-header {
            margin-bottom: 0;
            }
            .error-code {
            margin-top: 10px;
            }
            }
            /* Don't allow overflow when in a subframe. */
            html[subframe] body {
            overflow: hidden;
            }
            #sub-frame-error {
            -webkit-align-items: center;
            background-color: #DDD;
            display: -webkit-flex;
            -webkit-flex-flow: column;
            height: 100%;
            -webkit-justify-content: center;
            left: 0;
            position: absolute;
            top: 0;
            width: 100%;
            }
            #sub-frame-error:hover {
            background-color: #EEE;
            }
            #sub-frame-error-details {
            margin: 0 10px;
            visibility: hidden;
            }
            /* Show details only when hovering. */
            #sub-frame-error:hover #sub-frame-error-details {
            visibility: visible;
            }
            /* If the iframe is too small, always hide the error code. */
            /* TODO(mmenke): See if overflow: no-display works better, once supported. */
            @media (max-width: 200px), (max-height: 95px) {
            #sub-frame-error-details {
            display: none;
            }
            }
            /* details-button is special; it's a <button> element that looks like a link. */
            #details-button {
            background-color: inherit;
            background-image: none;
            border: none;
            box-shadow: none;
            min-width: 0;
            padding: 0;
            text-decoration: underline;
            }
            /* Styles for platform dependent separation of controls and details button. */
            .suggested-left > #control-buttons,
            .suggested-right > #details-button  {
            float: left;
            }
            .suggested-right > #control-buttons,
            .suggested-left > #details-button  {
            float: right;
            }
            #details-button.singular {
            float: none;
            }
            #buttons::after {
            clear: both;
            content: '';
            display: block;
            width: 100%;
            }
            /* Offline page */
            .offline .interstitial-wrapper {
            color: #2b2b2b;
            font-size: 1em;
            line-height: 1.55;
            margin: 100px auto 0;
            max-width: 600px;
            width: 100%;
            }
            .offline .runner-container {
            height: 150px;
            max-width: 600px;
            overflow: hidden;
            position: absolute;
            top: 10px;
            width: 44px;
            z-index: 2;
            }
            .offline .runner-canvas {
            height: 150px;
            max-width: 600px;
            opacity: 1;
            overflow: hidden;
            position: absolute;
            top: 0;
            }
            .offline .controller {
            background: rgba(247,247,247, .1);
            height: 100vh;
            left: 0;
            position: absolute;
            top: 0;
            width: 100vw;
            z-index: 1;
            }
            #offline-resources {
            display: none;
            }
            @media (max-width: 400px) {
            .suggested-left > #control-buttons,
            .suggested-right > #control-buttons {
            float: none;
            margin: 50px 0 20px;
            }
            }
            @media (max-height: 350px) {
            h1 {
            margin: 0 0 15px;
            }
            .icon-offline {
            margin: 0 0 10px;
            }
            .interstitial-wrapper {
            margin-top: 5%;
            }
            .nav-wrapper {
            margin-top: 30px;
            }
            }
            /*For tinybox */
            .tbox {position:absolute; display:none; padding:14px 17px; z-index:900;}
            .tinner { background:#fff url(http://www.skipser.com/activetemplate/images/loading1.gif) no-repeat 50% 50%;  border:10px solid #e3e3e3; border-radius:5px;}
            .tcontent {background-color:#fff; border-radius:5px;}
            .tmask {position:absolute; display:none; top:0px; left:0px; height:100%; width:100%; background:#000; z-index:800}
            .tclose {position:absolute; top:0px; right:0px; width:30px; height:30px; cursor:pointer; background:url(http://www.skipser.com/activetemplate/images/close.png) no-repeat}
            .tclose:hover {background-position:0 -30px}
            canvas { z-index:-10;overflow-y: auto;}
            input[type=text] {
                padding:5px;
                border:2px solid #ccc;
                -webkit-border-radius: 5px;
                border-radius: 5px;
            }
            input[type=text]:focus {
                border-color:#333;
            }
            input[type=submit] {
                padding:5px 15px;
                background:#ccc;
                border:0 none;
                cursor:pointer;
                -webkit-border-radius: 5px;
                border-radius: 5px;
            }
        </style>
		
    <body id="t">
            <div id="offline-resources" jstcache="0">
                <img id="offline-resources-1x" src="data:image/png;base64,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" jstcache="0">
                <img id="offline-resources-2x" src="data:image/png;base64,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" jstcache="0">
            </div>
            <div class='interstitial-wrapper'>
              <div class="runner-container"><canvas name="gamecanvas" class="runner-canvas" width="600" height="150" id="gamecanvas" style="width: 600px; height: 150px;"></canvas></div>
            </div>

<div id="me">
            <script type="text/javascript">
            // Copyright (c) 2014 The Chromium Authors. All rights reserved.
            // Use of this source code is governed by a BSD-style license that can be
            // found in the LICENSE file.
            (function() {
            'use strict';
            /**
             * T-Rex runner.
             * @param {string} outerContainerId Outer containing element id.
             * @param {Object} opt_config
             * @constructor
             * @export
             */
            function Runner(outerContainerId, opt_config) {
              // Singleton
              if (Runner.instance_) {
                return Runner.instance_;
              }
              Runner.instance_ = this;
              this.outerContainerEl = document.querySelector(outerContainerId);
              this.containerEl = null;
              this.snackbarEl = null;
              this.detailsButton = this.outerContainerEl.querySelector('#details-button');
              this.config = opt_config || Runner.config;
              this.dimensions = Runner.defaultDimensions;
              this.canvas = null;
              this.canvasCtx = null;
              this.tRex = null;
              this.distanceMeter = null;
              this.distanceRan = 0;
              this.highestScore = 0;
              this.time = 0;
              this.runningTime = 0;
              this.msPerFrame = 1000 / FPS;
              this.currentSpeed = this.config.SPEED;
              this.obstacles = [];
              this.started = false;
              this.activated = false;
              this.crashed = false;
              this.paused = false;
              this.inverted = false;
              this.invertTimer = 0;
              this.resizeTimerId_ = null;
              this.playCount = 0;
              // Sound FX.
              this.audioBuffer = null;
              this.soundFx = {};
              // Global web audio context for playing sounds.
              this.audioContext = null;
              // Images.
              this.images = {};
              this.imagesLoaded = 0;
              //if (this.isDisabled()) {
              //  this.setupDisabledRunner();
              //} else {
                this.loadImages();
              //}
            }
            window['Runner'] = Runner;
            /**
             * Default game width.
             * @const
             */
            var DEFAULT_WIDTH = 600;
            /**
             * Frames per second.
             * @const
             */
            var FPS = 60;
            /** @const */
            var IS_HIDPI = window.devicePixelRatio > 1;
            /** @const */
            var IS_IOS = window.navigator.userAgent.indexOf('CriOS') > -1 ||
                window.navigator.userAgent == 'UIWebViewForStaticFileContent';
            /** @const */
            var IS_MOBILE = window.navigator.userAgent.indexOf('Mobi') > -1 || IS_IOS;
            /** @const */
            var IS_TOUCH_ENABLED = 'ontouchstart' in window;
            /**
             * Default game configuration.
             * @enum {number}
             */
            Runner.config = {
              ACCELERATION: 0.001,
              BG_CLOUD_SPEED: 0.2,
              BOTTOM_PAD: 10,
              CLEAR_TIME: 3000,
              CLOUD_FREQUENCY: 0.5,
              GAMEOVER_CLEAR_TIME: 750,
              GAP_COEFFICIENT: 0.6,
              GRAVITY: 0.6,
              INITIAL_JUMP_VELOCITY: 12,
              INVERT_FADE_DURATION: 12000,
              INVERT_DISTANCE: 700,
              MAX_CLOUDS: 6,
              MAX_OBSTACLE_LENGTH: 3,
              MAX_OBSTACLE_DUPLICATION: 2,
              MAX_SPEED: 13,
              MIN_JUMP_HEIGHT: 35,
              MOBILE_SPEED_COEFFICIENT: 1.2,
              RESOURCE_TEMPLATE_ID: 'audio-resources',
              SPEED: 6,
              SPEED_DROP_COEFFICIENT: 3
            };
            /**
             * Default dimensions.
             * @enum {string}
             */
            Runner.defaultDimensions = {
              WIDTH: DEFAULT_WIDTH,
              HEIGHT: 150
            };
            /**
             * CSS class names.
             * @enum {string}
             */
            Runner.classes = {
              CANVAS: 'runner-canvas',
              CONTAINER: 'runner-container',
              CRASHED: 'crashed',
              ICON: 'icon-offline',
              INVERTED: 'inverted',
              SNACKBAR: 'snackbar',
              SNACKBAR_SHOW: 'snackbar-show',
              TOUCH_CONTROLLER: 'controller'
            };
            /**
             * Sprite definition layout of the spritesheet.
             * @enum {Object}
             */
            Runner.spriteDefinition = {
              LDPI: {
                CACTUS_LARGE: {x: 332, y: 2},
                CACTUS_SMALL: {x: 228, y: 2},
                CLOUD: {x: 86, y: 2},
                HORIZON: {x: 2, y: 54},
                MOON: {x: 484, y: 2},
                PTERODACTYL: {x: 134, y: 2},
                RESTART: {x: 2, y: 2},
                TEXT_SPRITE: {x: 655, y: 2},
                TREX: {x: 848, y: 2},
                STAR: {x: 645, y: 2}
              },
              HDPI: {
                CACTUS_LARGE: {x: 652, y: 2},
                CACTUS_SMALL: {x: 446, y: 2},
                CLOUD: {x: 166, y: 2},
                HORIZON: {x: 2, y: 104},
                MOON: {x: 954, y: 2},
                PTERODACTYL: {x: 260, y: 2},
                RESTART: {x: 2, y: 2},
                TEXT_SPRITE: {x: 1294, y: 2},
                TREX: {x: 1678, y: 2},
                STAR: {x: 1276, y: 2}
              }
            };
            /**
             * Key code mapping.
             * @enum {Object}
             */
            Runner.keycodes = {
              JUMP: {'38': 1, '32': 1},  // Up, spacebar
              DUCK: {'40': 1},  // Down
              RESTART: {'13': 1}  // Enter
            };
            /**
             * Runner event names.
             * @enum {string}
             */
            Runner.events = {
              ANIM_END: 'webkitAnimationEnd',
              CLICK: 'click',
              KEYDOWN: 'keydown',
              KEYUP: 'keyup',
              MOUSEDOWN: 'mousedown',
              MOUSEUP: 'mouseup',
              RESIZE: 'resize',
              TOUCHEND: 'touchend',
              TOUCHSTART: 'touchstart',
              VISIBILITY: 'visibilitychange',
              BLUR: 'blur',
              FOCUS: 'focus',
              LOAD: 'load'
            };
            Runner.prototype = {
              /**
               * Whether the easter egg has been disabled. CrOS enterprise enrolled devices.
               * @return {boolean}
               */
              //isDisabled: function() {
              //  return loadTimeData && loadTimeData.valueExists('disabledEasterEgg');
              //},
              /**
               * For disabled instances, set up a snackbar with the disabled message.
               */
              setupDisabledRunner: function() {
                /*this.containerEl = document.createElement('div');
                this.containerEl.className = Runner.classes.SNACKBAR;
                this.containerEl.textContent = loadTimeData.getValue('disabledEasterEgg');
                this.outerContainerEl.appendChild(this.containerEl);
                // Show notification when the activation key is pressed.
                document.addEventListener(Runner.events.KEYDOWN, function(e) {
                  if (Runner.keycodes.JUMP[e.keyCode]) {
                    this.containerEl.classList.add(Runner.classes.SNACKBAR_SHOW);
                    document.querySelector('.icon').classList.add('icon-disabled');
                  }
                }.bind(this));*/
              },
              /**
               * Setting individual settings for debugging.
               * @param {string} setting
               * @param {*} value
               */
              updateConfigSetting: function(setting, value) {
                if (setting in this.config && value != undefined) {
                  this.config[setting] = value;
                  switch (setting) {
                    case 'GRAVITY':
                    case 'MIN_JUMP_HEIGHT':
                    case 'SPEED_DROP_COEFFICIENT':
                      this.tRex.config[setting] = value;
                      break;
                    case 'INITIAL_JUMP_VELOCITY':
                      this.tRex.setJumpVelocity(value);
                      break;
                    case 'SPEED':
                      this.setSpeed(value);
                      break;
                  }
                }
              },
              /**
               * Cache the appropriate image sprite from the page and get the sprite sheet
               * definition.
               */
              loadImages: function() {
                if (IS_HIDPI) {
                  Runner.imageSprite = document.getElementById('offline-resources-2x');
                  this.spriteDef = Runner.spriteDefinition.HDPI;
                } else {
                  Runner.imageSprite = document.getElementById('offline-resources-1x');
                  this.spriteDef = Runner.spriteDefinition.LDPI;
                }
                this.init();
              },
              /**
               * Sets the game speed. Adjust the speed accordingly if on a smaller screen.
               * @param {number} opt_speed
               */
              setSpeed: function(opt_speed) {
                var speed = opt_speed || this.currentSpeed;
                // Reduce the speed on smaller mobile screens.
                if (this.dimensions.WIDTH < DEFAULT_WIDTH) {
                  var mobileSpeed = speed * this.dimensions.WIDTH / DEFAULT_WIDTH *
                      this.config.MOBILE_SPEED_COEFFICIENT;
                  this.currentSpeed = mobileSpeed > speed ? speed : mobileSpeed;
                } else if (opt_speed) {
                  this.currentSpeed = opt_speed;
                }
              },
              /**
               * Game initialiser.
               */
              init: function() {
                // Hide the static icon.
                //document.querySelector('.' + Runner.classes.ICON).style.visibility = 'hidden';
                this.adjustDimensions();
                this.setSpeed();
                this.containerEl = document.createElement('div');
                this.containerEl.className = Runner.classes.CONTAINER;
                // Player canvas container.
                this.canvas = createCanvas(this.containerEl, this.dimensions.WIDTH,
                    this.dimensions.HEIGHT, Runner.classes.PLAYER);
                this.canvas.id='gamecanvas';
                this.canvasCtx = this.canvas.getContext('2d');
                this.canvasCtx.fillStyle = '#f7f7f7';
                this.canvasCtx.fill();
                Runner.updateCanvasScaling(this.canvas);
                // Horizon contains clouds, obstacles and the ground.
                this.horizon = new Horizon(this.canvas, this.spriteDef, this.dimensions,
                    this.config.GAP_COEFFICIENT);
                // Distance meter
                this.distanceMeter = new DistanceMeter(this.canvas,
                      this.spriteDef.TEXT_SPRITE, this.dimensions.WIDTH);
                // Draw t-rex
                this.tRex = new Trex(this.canvas, this.spriteDef.TREX);
                this.outerContainerEl.appendChild(this.containerEl);
                if (IS_MOBILE) {
                  this.createTouchController();
                }
                this.startListening();
                this.update();
                window.addEventListener(Runner.events.RESIZE,
                    this.debounceResize.bind(this));
              },
              /**
               * Create the touch controller. A div that covers whole screen.
               */
              createTouchController: function() {
                this.touchController = document.createElement('div');
                this.touchController.className = Runner.classes.TOUCH_CONTROLLER;
              },
              /**
               * Debounce the resize event.
               */
              debounceResize: function() {
                if (!this.resizeTimerId_) {
                  this.resizeTimerId_ =
                      setInterval(this.adjustDimensions.bind(this), 250);
                }
              },
              /**
               * Adjust game space dimensions on resize.
               */
              adjustDimensions: function() {
                clearInterval(this.resizeTimerId_);
                this.resizeTimerId_ = null;
                var boxStyles = window.getComputedStyle(this.outerContainerEl);
                var padding = Number(boxStyles.paddingLeft.substr(0,
                    boxStyles.paddingLeft.length - 2));
                this.dimensions.WIDTH = this.outerContainerEl.offsetWidth - padding * 2;
                // Redraw the elements back onto the canvas.
                if (this.canvas) {
                  this.canvas.width = this.dimensions.WIDTH;
                  this.canvas.height = this.dimensions.HEIGHT;
                  Runner.updateCanvasScaling(this.canvas);
                  this.distanceMeter.calcXPos(this.dimensions.WIDTH);
                  this.clearCanvas();
                  this.horizon.update(0, 0, true);
                  this.tRex.update(0);
                  // Outer container and distance meter.
                  if (this.activated || this.crashed || this.paused) {
                    this.containerEl.style.width = this.dimensions.WIDTH + 'px';
                    this.containerEl.style.height = this.dimensions.HEIGHT + 'px';
                    this.distanceMeter.update(0, Math.ceil(this.distanceRan));
                    this.stop();
                  } else {
                    this.tRex.draw(0, 0);
                  }
                  // Game over panel.
                  if (this.crashed && this.gameOverPanel) {
                    this.gameOverPanel.updateDimensions(this.dimensions.WIDTH);
                    this.gameOverPanel.draw();
                  }
                }
              },
              /**
               * Play the game intro.
               * Canvas container width expands out to the full width.
               */
              playIntro: function() {
                if (!this.started && !this.crashed) {
                  this.playingIntro = true;
                  this.tRex.playingIntro = true;
                  // CSS animation definition.
                  var keyframes = '@-webkit-keyframes intro { ' +
                        'from { width:' + Trex.config.WIDTH + 'px }' +
                        'to { width: ' + this.dimensions.WIDTH + 'px }' +
                      '}';
                  document.styleSheets[1].insertRule(keyframes, 0);
                  this.containerEl.addEventListener(Runner.events.ANIM_END,
                      this.startGame.bind(this));
                  this.containerEl.style.webkitAnimation = 'intro .4s ease-out 1 both';
                  this.containerEl.style.width = this.dimensions.WIDTH + 'px';
                  if (this.touchController) {
                    this.outerContainerEl.appendChild(this.touchController);
                  }
                  this.activated = true;
                  this.started = true;
                } else if (this.crashed) {
                  this.restart();
                }
              },
              /**
               * Update the game status to started.
               */
              startGame: function() {
                this.runningTime = 0;
                this.playingIntro = false;
                this.tRex.playingIntro = false;
                this.containerEl.style.webkitAnimation = '';
                this.playCount++;
                // Handle tabbing off the page. Pause the current game.
                document.addEventListener(Runner.events.VISIBILITY,
                      this.onVisibilityChange.bind(this));
                window.addEventListener(Runner.events.BLUR,
                      this.onVisibilityChange.bind(this));
                window.addEventListener(Runner.events.FOCUS,
                      this.onVisibilityChange.bind(this));
              },
              clearCanvas: function() {
                this.canvasCtx.clearRect(0, 0, this.dimensions.WIDTH,
                    this.dimensions.HEIGHT);
              },
              /**
               * Update the game frame.
               */
              update: function() {
                this.drawPending = false;
                var now = getTimeStamp();
                var deltaTime = now - (this.time || now);
                this.time = now;
                if (this.activated) {
                  this.clearCanvas();
                  if (this.tRex.jumping) {
                    this.tRex.updateJump(deltaTime);
                  }
                  this.runningTime += deltaTime;
                  var hasObstacles = this.runningTime > this.config.CLEAR_TIME;
                  // First jump triggers the intro.
                  if (this.tRex.jumpCount == 1 && !this.playingIntro) {
                    this.playIntro();
                  }
                  // The horizon doesn't move until the intro is over.
                  if (this.playingIntro) {
                    this.horizon.update(0, this.currentSpeed, hasObstacles);
                  } else {
                    deltaTime = !this.started ? 0 : deltaTime;
                    this.horizon.update(deltaTime, this.currentSpeed, hasObstacles,
                        this.inverted);
                  }
                  // Check for collisions.
                  var collision = hasObstacles &&
                      checkForCollision(this.horizon.obstacles[0], this.tRex);
                  if (!collision) {
                    this.distanceRan += this.currentSpeed * deltaTime / this.msPerFrame;
                    if (this.currentSpeed < this.config.MAX_SPEED) {
                      this.currentSpeed += this.config.ACCELERATION;
                    }
                  } else {
                    this.gameOver();
                  }
                  // Night mode.
                  if (this.invertTimer > this.config.INVERT_FADE_DURATION) {
                    this.invertTimer = 0;
                    this.invertTrigger = false;
                    this.invert();
                  } else if (this.invertTimer) {
                    this.invertTimer += deltaTime;
                  } else {
                    var actualDistance =
                        this.distanceMeter.getActualDistance(Math.ceil(this.distanceRan));
                    if (actualDistance > 0) {
                      this.invertTrigger = !(actualDistance %
                          this.config.INVERT_DISTANCE);
                      if (this.invertTrigger && this.invertTimer === 0) {
                        this.invertTimer += deltaTime;
                        this.invert();
                      }
                    }
                  }
                }
                if (!this.crashed) {
                  this.tRex.update(deltaTime);
                  this.raq();
                }
              },
              /**
               * Event handler.
               */
              handleEvent: function(e) {
                return (function(evtType, events) {
                  switch (evtType) {
                    case events.KEYDOWN:
                    case events.TOUCHSTART:
                    case events.MOUSEDOWN:
                      this.onKeyDown(e);
                      break;
                    case events.KEYUP:
                    case events.TOUCHEND:
                    case events.MOUSEUP:
                      this.onKeyUp(e);
                      break;
                  }
                }.bind(this))(e.type, Runner.events);
              },
              /**
               * Bind relevant key / mouse / touch listeners.
               */
              startListening: function() {
                // Keys.
                document.addEventListener(Runner.events.KEYDOWN, this);
                document.addEventListener(Runner.events.KEYUP, this);
                if (IS_MOBILE) {
                  // Mobile only touch devices.
                  this.touchController.addEventListener(Runner.events.TOUCHSTART, this);
                  this.touchController.addEventListener(Runner.events.TOUCHEND, this);
                  this.containerEl.addEventListener(Runner.events.TOUCHSTART, this);
                } else {
                  // Mouse.
                  document.addEventListener(Runner.events.MOUSEDOWN, this);
                  document.addEventListener(Runner.events.MOUSEUP, this);
                }
              },
              /**
               * Remove all listeners.
               */
              stopListening: function() {
                document.removeEventListener(Runner.events.KEYDOWN, this);
                document.removeEventListener(Runner.events.KEYUP, this);
                if (IS_MOBILE) {
                  this.touchController.removeEventListener(Runner.events.TOUCHSTART, this);
                  this.touchController.removeEventListener(Runner.events.TOUCHEND, this);
                  this.containerEl.removeEventListener(Runner.events.TOUCHSTART, this);
                } else {
                  document.removeEventListener(Runner.events.MOUSEDOWN, this);
                  document.removeEventListener(Runner.events.MOUSEUP, this);
                }
              },
              /**
               * Process keydown.
               * @param {Event} e
               */
              onKeyDown: function(e) {
                // Prevent native page scrolling whilst tapping on mobile.
                if (IS_MOBILE) {
                  e.preventDefault();
                }
                if (e.target != this.detailsButton) {
                  if (!this.crashed && (Runner.keycodes.JUMP[e.keyCode] ||
                       e.type == Runner.events.TOUCHSTART)) {
                    if (!this.activated) {
                      this.activated = true;
                      //errorPageController.trackEasterEgg();
                    }
                    if (!this.tRex.jumping && !this.tRex.ducking) {
                      this.tRex.startJump(this.currentSpeed);
                    }
                  }
                  if (this.crashed && e.type == Runner.events.TOUCHSTART &&
                      e.currentTarget == this.containerEl) {
                    this.restart();
                  }
                }
                if (this.activated && !this.crashed && Runner.keycodes.DUCK[e.keyCode]) {
                  e.preventDefault();
                  if (this.tRex.jumping) {
                    // Speed drop, activated only when jump key is not pressed.
                    this.tRex.setSpeedDrop();
                  } else if (!this.tRex.jumping && !this.tRex.ducking) {
                    // Duck.
                    this.tRex.setDuck(true);
                  }
                }
              },
              /**
               * Process key up.
               * @param {Event} e
               */
              onKeyUp: function(e) {
                var keyCode = String(e.keyCode);
                var isjumpKey = Runner.keycodes.JUMP[keyCode] ||
                   e.type == Runner.events.TOUCHEND ||
                   e.type == Runner.events.MOUSEDOWN;
                if (this.isRunning() && isjumpKey) {
                  this.tRex.endJump();
                } else if (Runner.keycodes.DUCK[keyCode]) {
                  this.tRex.speedDrop = false;
                  this.tRex.setDuck(false);
                } else if (this.crashed) {
                  // Check that enough time has elapsed before allowing jump key to restart.
                  var deltaTime = getTimeStamp() - this.time;
                  if (Runner.keycodes.RESTART[keyCode] || this.isLeftClickOnCanvas(e) ||
                      (deltaTime >= this.config.GAMEOVER_CLEAR_TIME &&
                      Runner.keycodes.JUMP[keyCode])) {
                    this.restart();
                  }
                } else if (this.paused && isjumpKey) {
                  // Reset the jump state
                  this.tRex.reset();
                  this.play();
                }
              },
              /**
               * Returns whether the event was a left click on canvas.
               * On Windows right click is registered as a click.
               * @param {Event} e
               * @return {boolean}
               */
              isLeftClickOnCanvas: function(e) {
                return e.button != null && e.button < 2 &&
                    e.type == Runner.events.MOUSEUP && e.target == this.canvas;
              },
              /**
               * RequestAnimationFrame wrapper.
               */
              raq: function() {
                if (!this.drawPending) {
                  this.drawPending = true;
                  this.raqId = requestAnimationFrame(this.update.bind(this));
                }
              },
              /**
               * Whether the game is running.
               * @return {boolean}
               */
              isRunning: function() {
                return !!this.raqId;
              },
              /**
               * Game over state.
               */
              gameOver: function() {
                vibrate(200);
                this.stop();
                this.crashed = true;
                this.distanceMeter.acheivement = false;
                this.tRex.update(100, Trex.status.CRASHED);
                // Game over panel.
                if (!this.gameOverPanel) {
                  this.gameOverPanel = new GameOverPanel(this.canvas,
                      this.spriteDef.TEXT_SPRITE, this.spriteDef.RESTART,
                      this.dimensions);
                } else {
                  this.gameOverPanel.draw();
                }
                // Update the high score.
                if (this.distanceRan > this.highestScore) {
                  this.highestScore = Math.ceil(this.distanceRan);
                  this.distanceMeter.setHighScore(this.highestScore);
                }
                // Reset the time clock.
                this.time = getTimeStamp();
              },
              stop: function() {
                this.activated = false;
                this.paused = true;
                cancelAnimationFrame(this.raqId);
                this.raqId = 0;
              },
              play: function() {
                if (!this.crashed) {
                  this.activated = true;
                  this.paused = false;
                  this.tRex.update(0, Trex.status.RUNNING);
                  this.time = getTimeStamp();
                  this.update();
                }
              },
              restart: function() {
                if (!this.raqId) {
                  this.playCount++;
                  this.runningTime = 0;
                  this.activated = true;
                  this.crashed = false;
                  this.distanceRan = 0;
                  this.setSpeed(this.config.SPEED);
                  this.time = getTimeStamp();
                  this.containerEl.classList.remove(Runner.classes.CRASHED);
                  this.clearCanvas();
                  this.distanceMeter.reset(this.highestScore);
                  this.horizon.reset();
                  this.tRex.reset();
                  this.invert(true);
                  this.update();
                }
              },
              /**
               * Pause the game if the tab is not in focus.
               */
              onVisibilityChange: function(e) {
                if (document.hidden || document.webkitHidden || e.type == 'blur' ||
                  document.visibilityState != 'visible') {
                  this.stop();
                } else if (!this.crashed) {
                  this.tRex.reset();
                  this.play();
                }
              },
              /**
               * Inverts the current page / canvas colors.
               * @param {boolean} Whether to reset colors.
               */
              invert: function(reset) {
                if (reset) {
                  document.body.classList.toggle(Runner.classes.INVERTED, false);
                  this.invertTimer = 0;
                  this.inverted = false;
                } else {
                  this.inverted = document.body.classList.toggle(Runner.classes.INVERTED,
                      this.invertTrigger);
                }
              }
            };
            /**
             * Updates the canvas size taking into
             * account the backing store pixel ratio and
             * the device pixel ratio.
             *
             * See article by Paul Lewis:
             * http://www.html5rocks.com/en/tutorials/canvas/hidpi/
             *
             * @param {HTMLCanvasElement} canvas
             * @param {number} opt_width
             * @param {number} opt_height
             * @return {boolean} Whether the canvas was scaled.
             */
            Runner.updateCanvasScaling = function(canvas, opt_width, opt_height) {
              var context = canvas.getContext('2d');
              // Query the various pixel ratios
              var devicePixelRatio = Math.floor(window.devicePixelRatio) || 1;
              var backingStoreRatio = Math.floor(context.webkitBackingStorePixelRatio) || 1;
              var ratio = devicePixelRatio / backingStoreRatio;
              // Upscale the canvas if the two ratios don't match
              if (devicePixelRatio !== backingStoreRatio) {
                var oldWidth = opt_width || canvas.width;
                var oldHeight = opt_height || canvas.height;
                canvas.width = oldWidth * ratio;
                canvas.height = oldHeight * ratio;
                canvas.style.width = oldWidth + 'px';
                canvas.style.height = oldHeight + 'px';
                // Scale the context to counter the fact that we've manually scaled
                // our canvas element.
                context.scale(ratio, ratio);
                return true;
              } else if (devicePixelRatio == 1) {
                // Reset the canvas width / height. Fixes scaling bug when the page is
                // zoomed and the devicePixelRatio changes accordingly.
                canvas.style.width = canvas.width + 'px';
                canvas.style.height = canvas.height + 'px';
              }
              return false;
            };
            /**
             * Get random number.
             * @param {number} min
             * @param {number} max
             * @param {number}
             */
            function getRandomNum(min, max) {
              return Math.floor(Math.random() * (max - min + 1)) + min;
            }
            /**
             * Vibrate on mobile devices.
             * @param {number} duration Duration of the vibration in milliseconds.
             */
            function vibrate(duration) {
              if (IS_MOBILE && window.navigator.vibrate) {
                window.navigator.vibrate(duration);
              }
            }
            /**
             * Create canvas element.
             * @param {HTMLElement} container Element to append canvas to.
             * @param {number} width
             * @param {number} height
             * @param {string} opt_classname
             * @return {HTMLCanvasElement}
             */
            function createCanvas(container, width, height, opt_classname) {
              var canvas = document.createElement('canvas');
              canvas.className = opt_classname ? Runner.classes.CANVAS + ' ' +
                  opt_classname : Runner.classes.CANVAS;
              canvas.width = width;
              canvas.height = height;
              container.appendChild(canvas);
              return canvas;
            }
            /**
             * Decodes the base 64 audio to ArrayBuffer used by Web Audio.
             * @param {string} base64String
             */
            function decodeBase64ToArrayBuffer(base64String) {
              var len = (base64String.length / 4) * 3;
              var str = atob(base64String);
              var arrayBuffer = new ArrayBuffer(len);
              var bytes = new Uint8Array(arrayBuffer);
              for (var i = 0; i < len; i++) {
                bytes[i] = str.charCodeAt(i);
              }
              return bytes.buffer;
            }
            /**
             * Return the current timestamp.
             * @return {number}
             */
            function getTimeStamp() {
              return IS_IOS ? new Date().getTime() : performance.now();
            }
            //******************************************************************************
            /**
             * Game over panel.
             * @param {!HTMLCanvasElement} canvas
             * @param {Object} textImgPos
             * @param {Object} restartImgPos
             * @param {!Object} dimensions Canvas dimensions.
             * @constructor
             */
            function GameOverPanel(canvas, textImgPos, restartImgPos, dimensions) {
              this.canvas = canvas;
              this.canvasCtx = canvas.getContext('2d');
              this.canvasDimensions = dimensions;
              this.textImgPos = textImgPos;
              this.restartImgPos = restartImgPos;
              this.draw();
            };
            /**
             * Dimensions used in the panel.
             * @enum {number}
             */
            GameOverPanel.dimensions = {
              TEXT_X: 0,
              TEXT_Y: 13,
              TEXT_WIDTH: 191,
              TEXT_HEIGHT: 11,
              RESTART_WIDTH: 36,
              RESTART_HEIGHT: 32
            };
            GameOverPanel.prototype = {
              /**
               * Update the panel dimensions.
               * @param {number} width New canvas width.
               * @param {number} opt_height Optional new canvas height.
               */
              updateDimensions: function(width, opt_height) {
                this.canvasDimensions.WIDTH = width;
                if (opt_height) {
                  this.canvasDimensions.HEIGHT = opt_height;
                }
              },
              /**
               * Draw the panel.
               */
              draw: function() {
                var dimensions = GameOverPanel.dimensions;
                var centerX = this.canvasDimensions.WIDTH / 2;
                // Game over text.
                var textSourceX = dimensions.TEXT_X;
                var textSourceY = dimensions.TEXT_Y;
                var textSourceWidth = dimensions.TEXT_WIDTH;
                var textSourceHeight = dimensions.TEXT_HEIGHT;
                var textTargetX = Math.round(centerX - (dimensions.TEXT_WIDTH / 2));
                var textTargetY = Math.round((this.canvasDimensions.HEIGHT - 25) / 3);
                var textTargetWidth = dimensions.TEXT_WIDTH;
                var textTargetHeight = dimensions.TEXT_HEIGHT;
                var restartSourceWidth = dimensions.RESTART_WIDTH;
                var restartSourceHeight = dimensions.RESTART_HEIGHT;
                var restartTargetX = centerX - (dimensions.RESTART_WIDTH / 2);
                var restartTargetY = this.canvasDimensions.HEIGHT / 2;
                if (IS_HIDPI) {
                  textSourceY *= 2;
                  textSourceX *= 2;
                  textSourceWidth *= 2;
                  textSourceHeight *= 2;
                  restartSourceWidth *= 2;
                  restartSourceHeight *= 2;
                }
                textSourceX += this.textImgPos.x;
                textSourceY += this.textImgPos.y;
                // Game over text from sprite.
                this.canvasCtx.drawImage(Runner.imageSprite,
                    textSourceX, textSourceY, textSourceWidth, textSourceHeight,
                    textTargetX, textTargetY, textTargetWidth, textTargetHeight);
                // Restart button.
                this.canvasCtx.drawImage(Runner.imageSprite,
                    this.restartImgPos.x, this.restartImgPos.y,
                    restartSourceWidth, restartSourceHeight,
                    restartTargetX, restartTargetY, dimensions.RESTART_WIDTH,
                    dimensions.RESTART_HEIGHT);
              }
            };
            //******************************************************************************
            /**
             * Check for a collision.
             * @param {!Obstacle} obstacle
             * @param {!Trex} tRex T-rex object.
             * @param {HTMLCanvasContext} opt_canvasCtx Optional canvas context for drawing
             *    collision boxes.
             * @return {Array<CollisionBox>}
             */
            function checkForCollision(obstacle, tRex, opt_canvasCtx) {
              var obstacleBoxXPos = Runner.defaultDimensions.WIDTH + obstacle.xPos;
              // Adjustments are made to the bounding box as there is a 1 pixel white
              // border around the t-rex and obstacles.
              var tRexBox = new CollisionBox(
                  tRex.xPos + 1,
                  tRex.yPos + 1,
                  tRex.config.WIDTH - 2,
                  tRex.config.HEIGHT - 2);
              var obstacleBox = new CollisionBox(
                  obstacle.xPos + 1,
                  obstacle.yPos + 1,
                  obstacle.typeConfig.width * obstacle.size - 2,
                  obstacle.typeConfig.height - 2);
              // Debug outer box
              if (opt_canvasCtx) {
                drawCollisionBoxes(opt_canvasCtx, tRexBox, obstacleBox);
              }
              // Simple outer bounds check.
              if (boxCompare(tRexBox, obstacleBox)) {
                var collisionBoxes = obstacle.collisionBoxes;
                var tRexCollisionBoxes = tRex.ducking ?
                    Trex.collisionBoxes.DUCKING : Trex.collisionBoxes.RUNNING;
                // Detailed axis aligned box check.
                for (var t = 0; t < tRexCollisionBoxes.length; t++) {
                  for (var i = 0; i < collisionBoxes.length; i++) {
                    // Adjust the box to actual positions.
                    var adjTrexBox =
                        createAdjustedCollisionBox(tRexCollisionBoxes[t], tRexBox);
                    var adjObstacleBox =
                        createAdjustedCollisionBox(collisionBoxes[i], obstacleBox);
                    var crashed = boxCompare(adjTrexBox, adjObstacleBox);
                    // Draw boxes for debug.
                    if (opt_canvasCtx) {
                      drawCollisionBoxes(opt_canvasCtx, adjTrexBox, adjObstacleBox);
                    }
                    if (crashed) {
                      return [adjTrexBox, adjObstacleBox];
                    }
                  }
                }
              }
              return false;
            };
            /**
             * Adjust the collision box.
             * @param {!CollisionBox} box The original box.
             * @param {!CollisionBox} adjustment Adjustment box.
             * @return {CollisionBox} The adjusted collision box object.
             */
            function createAdjustedCollisionBox(box, adjustment) {
              return new CollisionBox(
                  box.x + adjustment.x,
                  box.y + adjustment.y,
                  box.width,
                  box.height);
            };
            /**
             * Draw the collision boxes for debug.
             */
            function drawCollisionBoxes(canvasCtx, tRexBox, obstacleBox) {
              canvasCtx.save();
              canvasCtx.strokeStyle = '#f00';
              canvasCtx.strokeRect(tRexBox.x, tRexBox.y, tRexBox.width, tRexBox.height);
              canvasCtx.strokeStyle = '#0f0';
              canvasCtx.strokeRect(obstacleBox.x, obstacleBox.y,
                  obstacleBox.width, obstacleBox.height);
              canvasCtx.restore();
            };
            /**
             * Compare two collision boxes for a collision.
             * @param {CollisionBox} tRexBox
             * @param {CollisionBox} obstacleBox
             * @return {boolean} Whether the boxes intersected.
             */
            function boxCompare(tRexBox, obstacleBox) {
              var crashed = false;
              var tRexBoxX = tRexBox.x;
              var tRexBoxY = tRexBox.y;
              var obstacleBoxX = obstacleBox.x;
              var obstacleBoxY = obstacleBox.y;
              // Axis-Aligned Bounding Box method.
              if (tRexBox.x < obstacleBoxX + obstacleBox.width &&
                  tRexBox.x + tRexBox.width > obstacleBoxX &&
                  tRexBox.y < obstacleBox.y + obstacleBox.height &&
                  tRexBox.height + tRexBox.y > obstacleBox.y) {
                crashed = true;
              }
              return crashed;
            };
            //******************************************************************************
            /**
             * Collision box object.
             * @param {number} x X position.
             * @param {number} y Y Position.
             * @param {number} w Width.
             * @param {number} h Height.
             */
            function CollisionBox(x, y, w, h) {
              this.x = x;
              this.y = y;
              this.width = w;
              this.height = h;
            };
            //******************************************************************************
            /**
             * Obstacle.
             * @param {HTMLCanvasCtx} canvasCtx
             * @param {Obstacle.type} type
             * @param {Object} spritePos Obstacle position in sprite.
             * @param {Object} dimensions
             * @param {number} gapCoefficient Mutipler in determining the gap.
             * @param {number} speed
             * @param {number} opt_xOffset
             */
            function Obstacle(canvasCtx, type, spriteImgPos, dimensions,
                gapCoefficient, speed, opt_xOffset) {
              this.canvasCtx = canvasCtx;
              this.spritePos = spriteImgPos;
              this.typeConfig = type;
              this.gapCoefficient = gapCoefficient;
              this.size = getRandomNum(1, Obstacle.MAX_OBSTACLE_LENGTH);
              this.dimensions = dimensions;
              this.remove = false;
              this.xPos = dimensions.WIDTH + (opt_xOffset || 0);
              this.yPos = 0;
              this.width = 0;
              this.collisionBoxes = [];
              this.gap = 0;
              this.speedOffset = 0;
              // For animated obstacles.
              this.currentFrame = 0;
              this.timer = 0;
              this.init(speed);
            };
            /**
             * Coefficient for calculating the maximum gap.
             * @const
             */
            Obstacle.MAX_GAP_COEFFICIENT = 1.5;
            /**
             * Maximum obstacle grouping count.
             * @const
             */
            Obstacle.MAX_OBSTACLE_LENGTH = 3,
            Obstacle.prototype = {
              /**
               * Initialise the DOM for the obstacle.
               * @param {number} speed
               */
              init: function(speed) {
                this.cloneCollisionBoxes();
                // Only allow sizing if we're at the right speed.
                if (this.size > 1 && this.typeConfig.multipleSpeed > speed) {
                  this.size = 1;
                }
                this.width = this.typeConfig.width * this.size;
                // Check if obstacle can be positioned at various heights.
                if (Array.isArray(this.typeConfig.yPos))  {
                  var yPosConfig = IS_MOBILE ? this.typeConfig.yPosMobile :
                      this.typeConfig.yPos;
                  this.yPos = yPosConfig[getRandomNum(0, yPosConfig.length - 1)];
                } else {
                  this.yPos = this.typeConfig.yPos;
                }
                this.draw();
                // Make collision box adjustments,
                // Central box is adjusted to the size as one box.
                //      ____        ______        ________
                //    _|   |-|    _|     |-|    _|       |-|
                //   | |<->| |   | |<--->| |   | |<----->| |
                //   | | 1 | |   | |  2  | |   | |   3   | |
                //   |_|___|_|   |_|_____|_|   |_|_______|_|
                //
                if (this.size > 1) {
                  this.collisionBoxes[1].width = this.width - this.collisionBoxes[0].width -
                      this.collisionBoxes[2].width;
                  this.collisionBoxes[2].x = this.width - this.collisionBoxes[2].width;
                }
                // For obstacles that go at a different speed from the horizon.
                if (this.typeConfig.speedOffset) {
                  this.speedOffset = Math.random() > 0.5 ? this.typeConfig.speedOffset :
                      -this.typeConfig.speedOffset;
                }
                this.gap = this.getGap(this.gapCoefficient, speed);
              },
              /**
               * Draw and crop based on size.
               */
              draw: function() {
                var sourceWidth = this.typeConfig.width;
                var sourceHeight = this.typeConfig.height;
                if (IS_HIDPI) {
                  sourceWidth = sourceWidth * 2;
                  sourceHeight = sourceHeight * 2;
                }
                // X position in sprite.
                var sourceX = (sourceWidth * this.size) * (0.5 * (this.size - 1)) +
                    this.spritePos.x;
                // Animation frames.
                if (this.currentFrame > 0) {
                  sourceX += sourceWidth * this.currentFrame;
                }
                this.canvasCtx.drawImage(Runner.imageSprite,
                  sourceX, this.spritePos.y,
                  sourceWidth * this.size, sourceHeight,
                  this.xPos, this.yPos,
                  this.typeConfig.width * this.size, this.typeConfig.height);
              },
              /**
               * Obstacle frame update.
               * @param {number} deltaTime
               * @param {number} speed
               */
              update: function(deltaTime, speed) {
                if (!this.remove) {
                  if (this.typeConfig.speedOffset) {
                    speed += this.speedOffset;
                  }
                  this.xPos -= Math.floor((speed * FPS / 1000) * deltaTime);
                  // Update frame
                  if (this.typeConfig.numFrames) {
                    this.timer += deltaTime;
                    if (this.timer >= this.typeConfig.frameRate) {
                      this.currentFrame =
                          this.currentFrame == this.typeConfig.numFrames - 1 ?
                          0 : this.currentFrame + 1;
                      this.timer = 0;
                    }
                  }
                  this.draw();
                  if (!this.isVisible()) {
                    this.remove = true;
                  }
                }
              },
              /**
               * Calculate a random gap size.
               * - Minimum gap gets wider as speed increses
               * @param {number} gapCoefficient
               * @param {number} speed
               * @return {number} The gap size.
               */
              getGap: function(gapCoefficient, speed) {
                var minGap = Math.round(this.width * speed +
                      this.typeConfig.minGap * gapCoefficient);
                var maxGap = Math.round(minGap * Obstacle.MAX_GAP_COEFFICIENT);
                return getRandomNum(minGap, maxGap);
              },
              /**
               * Check if obstacle is visible.
               * @return {boolean} Whether the obstacle is in the game area.
               */
              isVisible: function() {
                return this.xPos + this.width > 0;
              },
              /**
               * Make a copy of the collision boxes, since these will change based on
               * obstacle type and size.
               */
              cloneCollisionBoxes: function() {
                var collisionBoxes = this.typeConfig.collisionBoxes;
                for (var i = collisionBoxes.length - 1; i >= 0; i--) {
                  this.collisionBoxes[i] = new CollisionBox(collisionBoxes[i].x,
                      collisionBoxes[i].y, collisionBoxes[i].width,
                      collisionBoxes[i].height);
                }
              }
            };
            /**
             * Obstacle definitions.
             * minGap: minimum pixel space betweeen obstacles.
             * multipleSpeed: Speed at which multiples are allowed.
             * speedOffset: speed faster / slower than the horizon.
             * minSpeed: Minimum speed which the obstacle can make an appearance.
             */
            Obstacle.types = [
              {
                type: 'CACTUS_SMALL',
                width: 17,
                height: 35,
                yPos: 105,
                multipleSpeed: 4,
                minGap: 120,
                minSpeed: 0,
                collisionBoxes: [
                  new CollisionBox(0, 7, 5, 27),
                  new CollisionBox(4, 0, 6, 34),
                  new CollisionBox(10, 4, 7, 14)
                ]
              },
              {
                type: 'CACTUS_LARGE',
                width: 25,
                height: 50,
                yPos: 90,
                multipleSpeed: 7,
                minGap: 120,
                minSpeed: 0,
                collisionBoxes: [
                  new CollisionBox(0, 12, 7, 38),
                  new CollisionBox(8, 0, 7, 49),
                  new CollisionBox(13, 10, 10, 38)
                ]
              },
              {
                type: 'PTERODACTYL',
                width: 46,
                height: 40,
                yPos: [ 100, 75, 50 ], // Variable height.
                yPosMobile: [ 100, 50 ], // Variable height mobile.
                multipleSpeed: 999,
                minSpeed: 8.5,
                minGap: 150,
                collisionBoxes: [
                  new CollisionBox(15, 15, 16, 5),
                  new CollisionBox(18, 21, 24, 6),
                  new CollisionBox(2, 14, 4, 3),
                  new CollisionBox(6, 10, 4, 7),
                  new CollisionBox(10, 8, 6, 9)
                ],
                numFrames: 2,
                frameRate: 1000/6,
                speedOffset: .8
              }
            ];
            //******************************************************************************
            /**
             * T-rex game character.
             * @param {HTMLCanvas} canvas
             * @param {Object} spritePos Positioning within image sprite.
             * @constructor
             */
            function Trex(canvas, spritePos) {
              this.canvas = canvas;
              this.canvasCtx = canvas.getContext('2d');
              this.spritePos = spritePos;
              this.xPos = 0;
              this.yPos = 0;
              // Position when on the ground.
              this.groundYPos = 0;
              this.currentFrame = 0;
              this.currentAnimFrames = [];
              this.blinkDelay = 0;
              this.animStartTime = 0;
              this.timer = 0;
              this.msPerFrame = 1000 / FPS;
              this.config = Trex.config;
              // Current status.
              this.status = Trex.status.WAITING;
              this.jumping = false;
              this.ducking = false;
              this.jumpVelocity = 0;
              this.reachedMinHeight = false;
              this.speedDrop = false;
              this.jumpCount = 0;
              this.jumpspotX = 0;
              this.init();
            };
            /**
             * T-rex player config.
             * @enum {number}
             */
            Trex.config = {
              DROP_VELOCITY: -5,
              GRAVITY: 0.6,
              HEIGHT: 47,
              HEIGHT_DUCK: 25,
              INIITAL_JUMP_VELOCITY: -10,
              INTRO_DURATION: 1500,
              MAX_JUMP_HEIGHT: 30,
              MIN_JUMP_HEIGHT: 30,
              SPEED_DROP_COEFFICIENT: 3,
              SPRITE_WIDTH: 262,
              START_X_POS: 50,
              WIDTH: 44,
              WIDTH_DUCK: 59
            };
            /**
             * Used in collision detection.
             * @type {Array<CollisionBox>}
             */
            Trex.collisionBoxes = {
              DUCKING: [
                new CollisionBox(1, 18, 55, 25)
              ],
              RUNNING: [
                new CollisionBox(22, 0, 17, 16),
                new CollisionBox(1, 18, 30, 9),
                new CollisionBox(10, 35, 14, 8),
                new CollisionBox(1, 24, 29, 5),
                new CollisionBox(5, 30, 21, 4),
                new CollisionBox(9, 34, 15, 4)
              ]
            };
            /**
             * Animation states.
             * @enum {string}
             */
            Trex.status = {
              CRASHED: 'CRASHED',
              DUCKING: 'DUCKING',
              JUMPING: 'JUMPING',
              RUNNING: 'RUNNING',
              WAITING: 'WAITING'
            };
            /**
             * Blinking coefficient.
             * @const
             */
            Trex.BLINK_TIMING = 7000;
            /**
             * Animation config for different states.
             * @enum {Object}
             */
            Trex.animFrames = {
              WAITING: {
                frames: [44, 0],
                msPerFrame: 1000 / 3
              },
              RUNNING: {
                frames: [88, 132],
                msPerFrame: 1000 / 12
              },
              CRASHED: {
                frames: [220],
                msPerFrame: 1000 / 60
              },
              JUMPING: {
                frames: [0],
                msPerFrame: 1000 / 60
              },
              DUCKING: {
                frames: [262, 321],
                msPerFrame: 1000 / 8
              }
            };
            Trex.prototype = {
              /**
               * T-rex player initaliser.
               * Sets the t-rex to blink at random intervals.
               */
              init: function() {
                this.blinkDelay = this.setBlinkDelay();
                this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -
                    Runner.config.BOTTOM_PAD;
                this.yPos = this.groundYPos;
                this.minJumpHeight = this.groundYPos - this.config.MIN_JUMP_HEIGHT;
                this.draw(0, 0);
                this.update(0, Trex.status.WAITING);
              },
              /**
               * Setter for the jump velocity.
               * The approriate drop velocity is also set.
               */
              setJumpVelocity: function(setting) {
                this.config.INIITAL_JUMP_VELOCITY = -setting;
                this.config.DROP_VELOCITY = -setting / 2;
              },
              /**
               * Set the animation status.
               * @param {!number} deltaTime
               * @param {Trex.status} status Optional status to switch to.
               */
              update: function(deltaTime, opt_status) {
                this.timer += deltaTime;
                // Update the status.
                if (opt_status) {
                  this.status = opt_status;
                  this.currentFrame = 0;
                  this.msPerFrame = Trex.animFrames[opt_status].msPerFrame;
                  this.currentAnimFrames = Trex.animFrames[opt_status].frames;
                  if (opt_status == Trex.status.WAITING) {
                    this.animStartTime = getTimeStamp();
                    this.setBlinkDelay();
                  }
                }
                // Game intro animation, T-rex moves in from the left.
                if (this.playingIntro && this.xPos < this.config.START_X_POS) {
                  this.xPos += Math.round((this.config.START_X_POS /
                      this.config.INTRO_DURATION) * deltaTime);
                }
                if (this.status == Trex.status.WAITING) {
                  this.blink(getTimeStamp());
                } else {
                  this.draw(this.currentAnimFrames[this.currentFrame], 0);
                }
                // Update the frame position.
                if (this.timer >= this.msPerFrame) {
                  this.currentFrame = this.currentFrame ==
                      this.currentAnimFrames.length - 1 ? 0 : this.currentFrame + 1;
                  this.timer = 0;
                }
                // Speed drop becomes duck if the down key is still being pressed.
                if (this.speedDrop && this.yPos == this.groundYPos) {
                  this.speedDrop = false;
                  this.setDuck(true);
                }
              },
              /**
               * Draw the t-rex to a particular position.
               * @param {number} x
               * @param {number} y
               */
              draw: function(x, y) {
                var sourceX = x;
                var sourceY = y;
                var sourceWidth = this.ducking && this.status != Trex.status.CRASHED ?
                    this.config.WIDTH_DUCK : this.config.WIDTH;
                var sourceHeight = this.config.HEIGHT;
                if (IS_HIDPI) {
                  sourceX *= 2;
                  sourceY *= 2;
                  sourceWidth *= 2;
                  sourceHeight *= 2;
                }
                // Adjustments for sprite sheet position.
                sourceX += this.spritePos.x;
                sourceY += this.spritePos.y;
                // Ducking.
                if (this.ducking && this.status != Trex.status.CRASHED) {
                  this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,
                      sourceWidth, sourceHeight,
                      this.xPos, this.yPos,
                      this.config.WIDTH_DUCK, this.config.HEIGHT);
                } else {
                  // Crashed whilst ducking. Trex is standing up so needs adjustment.
                  if (this.ducking && this.status == Trex.status.CRASHED) {
                    this.xPos++;
                  }
                  // Standing / running
                  this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,
                      sourceWidth, sourceHeight,
                      this.xPos, this.yPos,
                      this.config.WIDTH, this.config.HEIGHT);
                }
              },
              /**
               * Sets a random time for the blink to happen.
               */
              setBlinkDelay: function() {
                this.blinkDelay = Math.ceil(Math.random() * Trex.BLINK_TIMING);
              },
              /**
               * Make t-rex blink at random intervals.
               * @param {number} time Current time in milliseconds.
               */
              blink: function(time) {
                var deltaTime = time - this.animStartTime;
                if (deltaTime >= this.blinkDelay) {
                  this.draw(this.currentAnimFrames[this.currentFrame], 0);
                  if (this.currentFrame == 1) {
                    // Set new random delay to blink.
                    this.setBlinkDelay();
                    this.animStartTime = time;
                  }
                }
              },
              /**
               * Initialise a jump.
               * @param {number} speed
               */
              startJump: function(speed) {
                if (!this.jumping) {
                  this.update(0, Trex.status.JUMPING);
                  // Tweak the jump velocity based on the speed.
                  this.jumpVelocity = this.config.INIITAL_JUMP_VELOCITY - (speed / 10);
                  this.jumping = true;
                  this.reachedMinHeight = false;
                  this.speedDrop = false;
                }
              },
              /**
               * Jump is complete, falling down.
               */
              endJump: function() {
                if (this.reachedMinHeight &&
                    this.jumpVelocity < this.config.DROP_VELOCITY) {
                  this.jumpVelocity = this.config.DROP_VELOCITY;
                }
              },
              /**
               * Update frame for a jump.
               * @param {number} deltaTime
               * @param {number} speed
               */
              updateJump: function(deltaTime, speed) {
                var msPerFrame = Trex.animFrames[this.status].msPerFrame;
                var framesElapsed = deltaTime / msPerFrame;
                // Speed drop makes Trex fall faster.
                if (this.speedDrop) {
                  this.yPos += Math.round(this.jumpVelocity *
                      this.config.SPEED_DROP_COEFFICIENT * framesElapsed);
                } else {
                  this.yPos += Math.round(this.jumpVelocity * framesElapsed);
                }
                this.jumpVelocity += this.config.GRAVITY * framesElapsed;
                // Minimum height has been reached.
                if (this.yPos < this.minJumpHeight || this.speedDrop) {
                  this.reachedMinHeight = true;
                }
                // Reached max height
                if (this.yPos < this.config.MAX_JUMP_HEIGHT || this.speedDrop) {
                  this.endJump();
                }
                // Back down at ground level. Jump completed.
                if (this.yPos > this.groundYPos) {
                  this.reset();
                  this.jumpCount++;
                }
                this.update(deltaTime);
              },
              /**
               * Set the speed drop. Immediately cancels the current jump.
               */
              setSpeedDrop: function() {
                this.speedDrop = true;
                this.jumpVelocity = 1;
              },
              /**
               * @param {boolean} isDucking.
               */
              setDuck: function(isDucking) {
                if (isDucking && this.status != Trex.status.DUCKING) {
                  this.update(0, Trex.status.DUCKING);
                  this.ducking = true;
                } else if (this.status == Trex.status.DUCKING) {
                  this.update(0, Trex.status.RUNNING);
                  this.ducking = false;
                }
              },
              /**
               * Reset the t-rex to running at start of game.
               */
              reset: function() {
                this.yPos = this.groundYPos;
                this.jumpVelocity = 0;
                this.jumping = false;
                this.ducking = false;
                this.update(0, Trex.status.RUNNING);
                this.midair = false;
                this.speedDrop = false;
                this.jumpCount = 0;
              }
            };
            //******************************************************************************
            /**
             * Handles displaying the distance meter.
             * @param {!HTMLCanvasElement} canvas
             * @param {Object} spritePos Image position in sprite.
             * @param {number} canvasWidth
             * @constructor
             */
            function DistanceMeter(canvas, spritePos, canvasWidth) {
              this.canvas = canvas;
              this.canvasCtx = canvas.getContext('2d');
              this.image = Runner.imageSprite;
              this.spritePos = spritePos;
              this.x = 0;
              this.y = 5;
              this.currentDistance = 0;
              this.maxScore = 0;
              this.highScore = 0;
              this.container = null;
              this.digits = [];
              this.acheivement = false;
              this.defaultString = '';
              this.flashTimer = 0;
              this.flashIterations = 0;
              this.invertTrigger = false;
              this.config = DistanceMeter.config;
              this.maxScoreUnits = this.config.MAX_DISTANCE_UNITS;
              this.init(canvasWidth);
            };
            /**
             * @enum {number}
             */
            DistanceMeter.dimensions = {
              WIDTH: 10,
              HEIGHT: 13,
              DEST_WIDTH: 11
            };
            /**
             * Y positioning of the digits in the sprite sheet.
             * X position is always 0.
             * @type {Array<number>}
             */
            DistanceMeter.yPos = [0, 13, 27, 40, 53, 67, 80, 93, 107, 120];
            /**
             * Distance meter config.
             * @enum {number}
             */
            DistanceMeter.config = {
              // Number of digits.
              MAX_DISTANCE_UNITS: 5,
              // Distance that causes achievement animation.
              ACHIEVEMENT_DISTANCE: 100,
              // Used for conversion from pixel distance to a scaled unit.
              COEFFICIENT: 0.025,
              // Flash duration in milliseconds.
              FLASH_DURATION: 1000 / 4,
              // Flash iterations for achievement animation.
              FLASH_ITERATIONS: 3
            };
            DistanceMeter.prototype = {
              /**
               * Initialise the distance meter to '00000'.
               * @param {number} width Canvas width in px.
               */
              init: function(width) {
                var maxDistanceStr = '';
                this.calcXPos(width);
                this.maxScore = this.maxScoreUnits;
                for (var i = 0; i < this.maxScoreUnits; i++) {
                  this.draw(i, 0);
                  this.defaultString += '0';
                  maxDistanceStr += '9';
                }
                this.maxScore = parseInt(maxDistanceStr);
              },
              /**
               * Calculate the xPos in the canvas.
               * @param {number} canvasWidth
               */
              calcXPos: function(canvasWidth) {
                this.x = canvasWidth - (DistanceMeter.dimensions.DEST_WIDTH *
                    (this.maxScoreUnits + 1));
              },
              /**
               * Draw a digit to canvas.
               * @param {number} digitPos Position of the digit.
               * @param {number} value Digit value 0-9.
               * @param {boolean} opt_highScore Whether drawing the high score.
               */
              draw: function(digitPos, value, opt_highScore) {
                var sourceWidth = DistanceMeter.dimensions.WIDTH;
                var sourceHeight = DistanceMeter.dimensions.HEIGHT;
                var sourceX = DistanceMeter.dimensions.WIDTH * value;
                var sourceY = 0;
                var targetX = digitPos * DistanceMeter.dimensions.DEST_WIDTH;
                var targetY = this.y;
                var targetWidth = DistanceMeter.dimensions.WIDTH;
                var targetHeight = DistanceMeter.dimensions.HEIGHT;
                // For high DPI we 2x source values.
                if (IS_HIDPI) {
                  sourceWidth *= 2;
                  sourceHeight *= 2;
                  sourceX *= 2;
                }
                sourceX += this.spritePos.x;
                sourceY += this.spritePos.y;
                this.canvasCtx.save();
                if (opt_highScore) {
                  // Left of the current score.
                  var highScoreX = this.x - (this.maxScoreUnits * 2) *
                      DistanceMeter.dimensions.WIDTH;
                  this.canvasCtx.translate(highScoreX, this.y);
                } else {
                  this.canvasCtx.translate(this.x, this.y);
                }
                this.canvasCtx.drawImage(this.image, sourceX, sourceY,
                    sourceWidth, sourceHeight,
                    targetX, targetY,
                    targetWidth, targetHeight
                  );
                this.canvasCtx.restore();
              },
              /**
               * Covert pixel distance to a 'real' distance.
               * @param {number} distance Pixel distance ran.
               * @return {number} The 'real' distance ran.
               */
              getActualDistance: function(distance) {
                return distance ? Math.round(distance * this.config.COEFFICIENT) : 0;
              },
              /**
               * Update the distance meter.
               * @param {number} distance
               * @param {number} deltaTime
               * @return {boolean} Whether the acheivement sound fx should be played.
               */
              update: function(deltaTime, distance) {
                var paint = true;
                if (!this.acheivement) {
                  distance = this.getActualDistance(distance);
                  // Score has gone beyond the initial digit count.
                  if (distance > this.maxScore && this.maxScoreUnits ==
                    this.config.MAX_DISTANCE_UNITS) {
                    this.maxScoreUnits++;
                    this.maxScore = parseInt(this.maxScore + '9');
                  } else {
                    this.distance = 0;
                  }
                  if (distance > 0) {
                    // Acheivement unlocked
                    if (distance % this.config.ACHIEVEMENT_DISTANCE == 0) {
                      // Flash score and play sound.
                      this.acheivement = true;
                      this.flashTimer = 0;
                    }
                    // Create a string representation of the distance with leading 0.
                    var distanceStr = (this.defaultString +
                        distance).substr(-this.maxScoreUnits);
                    this.digits = distanceStr.split('');
                  } else {
                    this.digits = this.defaultString.split('');
                  }
                } else {
                  // Control flashing of the score on reaching acheivement.
                  if (this.flashIterations <= this.config.FLASH_ITERATIONS) {
                    this.flashTimer += deltaTime;
                    if (this.flashTimer < this.config.FLASH_DURATION) {
                      paint = false;
                    } else if (this.flashTimer >
                        this.config.FLASH_DURATION * 2) {
                      this.flashTimer = 0;
                      this.flashIterations++;
                    }
                  } else {
                    this.acheivement = false;
                    this.flashIterations = 0;
                    this.flashTimer = 0;
                  }
                }
                // Draw the digits if not flashing.
                if (paint) {
                  for (var i = this.digits.length - 1; i >= 0; i--) {
                    this.draw(i, parseInt(this.digits[i]));
                  }
                }
                this.drawHighScore();
                return false;
              },
              /**
               * Draw the high score.
               */
              drawHighScore: function() {
                this.canvasCtx.save();
                this.canvasCtx.globalAlpha = .8;
                for (var i = this.highScore.length - 1; i >= 0; i--) {
                  this.draw(i, parseInt(this.highScore[i], 10), true);
                }
                this.canvasCtx.restore();
              },
              /**
               * Set the highscore as a array string.
               * Position of char in the sprite: H - 10, I - 11.
               * @param {number} distance Distance ran in pixels.
               */
              setHighScore: function(distance) {
                distance = this.getActualDistance(distance);
                var highScoreStr = (this.defaultString +
                    distance).substr(-this.maxScoreUnits);
                this.highScore = ['10', '11', ''].concat(highScoreStr.split(''));
              },
              /**
               * Reset the distance meter back to '00000'.
               */
              reset: function() {
                this.update(0);
                this.acheivement = false;
              }
            };
            //******************************************************************************
            /**
             * Cloud background item.
             * Similar to an obstacle object but without collision boxes.
             * @param {HTMLCanvasElement} canvas Canvas element.
             * @param {Object} spritePos Position of image in sprite.
             * @param {number} containerWidth
             */
            function Cloud(canvas, spritePos, containerWidth) {
              this.canvas = canvas;
              this.canvasCtx = this.canvas.getContext('2d');
              this.spritePos = spritePos;
              this.containerWidth = containerWidth;
              this.xPos = containerWidth;
              this.yPos = 0;
              this.remove = false;
              this.cloudGap = getRandomNum(Cloud.config.MIN_CLOUD_GAP,
                  Cloud.config.MAX_CLOUD_GAP);
              this.init();
            };
            /**
             * Cloud object config.
             * @enum {number}
             */
            Cloud.config = {
              HEIGHT: 14,
              MAX_CLOUD_GAP: 400,
              MAX_SKY_LEVEL: 30,
              MIN_CLOUD_GAP: 100,
              MIN_SKY_LEVEL: 71,
              WIDTH: 46
            };
            Cloud.prototype = {
              /**
               * Initialise the cloud. Sets the Cloud height.
               */
              init: function() {
                this.yPos = getRandomNum(Cloud.config.MAX_SKY_LEVEL,
                    Cloud.config.MIN_SKY_LEVEL);
                this.draw();
              },
              /**
               * Draw the cloud.
               */
              draw: function() {
                this.canvasCtx.save();
                var sourceWidth = Cloud.config.WIDTH;
                var sourceHeight = Cloud.config.HEIGHT;
                if (IS_HIDPI) {
                  sourceWidth = sourceWidth * 2;
                  sourceHeight = sourceHeight * 2;
                }
                this.canvasCtx.drawImage(Runner.imageSprite, this.spritePos.x,
                    this.spritePos.y,
                    sourceWidth, sourceHeight,
                    this.xPos, this.yPos,
                    Cloud.config.WIDTH, Cloud.config.HEIGHT);
                this.canvasCtx.restore();
              },
              /**
               * Update the cloud position.
               * @param {number} speed
               */
              update: function(speed) {
                if (!this.remove) {
                  this.xPos -= Math.ceil(speed);
                  this.draw();
                  // Mark as removeable if no longer in the canvas.
                  if (!this.isVisible()) {
                    this.remove = true;
                  }
                }
              },
              /**
               * Check if the cloud is visible on the stage.
               * @return {boolean}
               */
              isVisible: function() {
                return this.xPos + Cloud.config.WIDTH > 0;
              }
            };
            //******************************************************************************
            /**
             * Nightmode shows a moon and stars on the horizon.
             */
            function NightMode(canvas, spritePos, containerWidth) {
              this.spritePos = spritePos;
              this.canvas = canvas;
              this.canvasCtx = canvas.getContext('2d');
              this.xPos = containerWidth - 50;
              this.yPos = 30;
              this.currentPhase = 0;
              this.opacity = 0;
              this.containerWidth = containerWidth;
              this.stars = [];
              this.drawStars = false;
              this.placeStars();
            };
            /**
             * @enum {number}
             */
            NightMode.config = {
              FADE_SPEED: 0.035,
              HEIGHT: 40,
              MOON_SPEED: 0.25,
              NUM_STARS: 2,
              STAR_SIZE: 9,
              STAR_SPEED: 0.3,
              STAR_MAX_Y: 70,
              WIDTH: 20
            };
            NightMode.phases = [140, 120, 100, 60, 40, 20, 0];
            NightMode.prototype = {
              /**
               * Update moving moon, changing phases.
               * @param {boolean} activated Whether night mode is activated.
               * @param {number} delta
               */
              update: function(activated, delta) {
                // Moon phase.
                if (activated && this.opacity == 0) {
                  this.currentPhase++;
                  if (this.currentPhase >= NightMode.phases.length) {
                    this.currentPhase = 0;
                  }
                }
                // Fade in / out.
                if (activated && (this.opacity < 1 || this.opacity == 0)) {
                  this.opacity += NightMode.config.FADE_SPEED;
                } else if (this.opacity > 0) {
                  this.opacity -= NightMode.config.FADE_SPEED;
                }
                // Set moon positioning.
                if (this.opacity > 0) {
                  this.xPos = this.updateXPos(this.xPos, NightMode.config.MOON_SPEED);
                  // Update stars.
                  if (this.drawStars) {
                     for (var i = 0; i < NightMode.config.NUM_STARS; i++) {
                        this.stars[i].x = this.updateXPos(this.stars[i].x,
                            NightMode.config.STAR_SPEED);
                     }
                  }
                  this.draw();
                } else {
                  this.opacity = 0;
                  this.placeStars();
                }
                this.drawStars = true;
              },
              updateXPos: function(currentPos, speed) {
                if (currentPos < -NightMode.config.WIDTH) {
                  currentPos = this.containerWidth;
                } else {
                  currentPos -= speed;
                }
                return currentPos;
              },
              draw: function() {
                var moonSourceWidth = this.currentPhase == 3 ? NightMode.config.WIDTH * 2 :
                     NightMode.config.WIDTH;
                var moonSourceHeight = NightMode.config.HEIGHT;
                var moonSourceX = this.spritePos.x + NightMode.phases[this.currentPhase];
                var moonOutputWidth = moonSourceWidth;
                var starSize = NightMode.config.STAR_SIZE;
                var starSourceX = Runner.spriteDefinition.LDPI.STAR.x;
                if (IS_HIDPI) {
                  moonSourceWidth *= 2;
                  moonSourceHeight *= 2;
                  moonSourceX = this.spritePos.x +
                      (NightMode.phases[this.currentPhase] * 2);
                  starSize *= 2;
                  starSourceX = Runner.spriteDefinition.HDPI.STAR.x;
                }
                this.canvasCtx.save();
                this.canvasCtx.globalAlpha = this.opacity;
                // Stars.
                if (this.drawStars) {
                  for (var i = 0; i < NightMode.config.NUM_STARS; i++) {
                    this.canvasCtx.drawImage(Runner.imageSprite,
                        starSourceX, this.stars[i].sourceY, starSize, starSize,
                        Math.round(this.stars[i].x), this.stars[i].y,
                        NightMode.config.STAR_SIZE, NightMode.config.STAR_SIZE);
                  }
                }
                // Moon.
                this.canvasCtx.drawImage(Runner.imageSprite, moonSourceX,
                    this.spritePos.y, moonSourceWidth, moonSourceHeight,
                    Math.round(this.xPos), this.yPos,
                    moonOutputWidth, NightMode.config.HEIGHT);
                this.canvasCtx.globalAlpha = 1;
                this.canvasCtx.restore();
              },
              // Do star placement.
              placeStars: function() {
                var segmentSize = Math.round(this.containerWidth /
                    NightMode.config.NUM_STARS);
                for (var i = 0; i < NightMode.config.NUM_STARS; i++) {
                  this.stars[i] = {};
                  this.stars[i].x = getRandomNum(segmentSize * i, segmentSize * (i + 1));
                  this.stars[i].y = getRandomNum(0, NightMode.config.STAR_MAX_Y);
                  if (IS_HIDPI) {
                    this.stars[i].sourceY = Runner.spriteDefinition.HDPI.STAR.y +
                        NightMode.config.STAR_SIZE * 2 * i;
                  } else {
                    this.stars[i].sourceY = Runner.spriteDefinition.LDPI.STAR.y +
                        NightMode.config.STAR_SIZE * i;
                  }
                }
              },
              reset: function() {
                this.currentPhase = 0;
                this.opacity = 0;
                this.update(false);
              }
            };
            //******************************************************************************
            /**
             * Horizon Line.
             * Consists of two connecting lines. Randomly assigns a flat / bumpy horizon.
             * @param {HTMLCanvasElement} canvas
             * @param {Object} spritePos Horizon position in sprite.
             * @constructor
             */
            function HorizonLine(canvas, spritePos) {
              this.spritePos = spritePos;
              this.canvas = canvas;
              this.canvasCtx = canvas.getContext('2d');
              this.sourceDimensions = {};
              this.dimensions = HorizonLine.dimensions;
              this.sourceXPos = [this.spritePos.x, this.spritePos.x +
                  this.dimensions.WIDTH];
              this.xPos = [];
              this.yPos = 0;
              this.bumpThreshold = 0.5;
              this.setSourceDimensions();
              this.draw();
            };
            /**
             * Horizon line dimensions.
             * @enum {number}
             */
            HorizonLine.dimensions = {
              WIDTH: 600,
              HEIGHT: 12,
              YPOS: 127
            };
            HorizonLine.prototype = {
              /**
               * Set the source dimensions of the horizon line.
               */
              setSourceDimensions: function() {
                for (var dimension in HorizonLine.dimensions) {
                  if (IS_HIDPI) {
                    if (dimension != 'YPOS') {
                      this.sourceDimensions[dimension] =
                          HorizonLine.dimensions[dimension] * 2;
                    }
                  } else {
                    this.sourceDimensions[dimension] =
                        HorizonLine.dimensions[dimension];
                  }
                  this.dimensions[dimension] = HorizonLine.dimensions[dimension];
                }
                this.xPos = [0, HorizonLine.dimensions.WIDTH];
                this.yPos = HorizonLine.dimensions.YPOS;
              },
              /**
               * Return the crop x position of a type.
               */
              getRandomType: function() {
                return Math.random() > this.bumpThreshold ? this.dimensions.WIDTH : 0;
              },
              /**
               * Draw the horizon line.
               */
              draw: function() {
                this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[0],
                    this.spritePos.y,
                    this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,
                    this.xPos[0], this.yPos,
                    this.dimensions.WIDTH, this.dimensions.HEIGHT);
                this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[1],
                    this.spritePos.y,
                    this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,
                    this.xPos[1], this.yPos,
                    this.dimensions.WIDTH, this.dimensions.HEIGHT);
              },
              /**
               * Update the x position of an indivdual piece of the line.
               * @param {number} pos Line position.
               * @param {number} increment
               */
              updateXPos: function(pos, increment) {
                var line1 = pos;
                var line2 = pos == 0 ? 1 : 0;
                this.xPos[line1] -= increment;
                this.xPos[line2] = this.xPos[line1] + this.dimensions.WIDTH;
                if (this.xPos[line1] <= -this.dimensions.WIDTH) {
                  this.xPos[line1] += this.dimensions.WIDTH * 2;
                  this.xPos[line2] = this.xPos[line1] - this.dimensions.WIDTH;
                  this.sourceXPos[line1] = this.getRandomType() + this.spritePos.x;
                }
              },
              /**
               * Update the horizon line.
               * @param {number} deltaTime
               * @param {number} speed
               */
              update: function(deltaTime, speed) {
                var increment = Math.floor(speed * (FPS / 1000) * deltaTime);
                if (this.xPos[0] <= 0) {
                  this.updateXPos(0, increment);
                } else {
                  this.updateXPos(1, increment);
                }
                this.draw();
              },
              /**
               * Reset horizon to the starting position.
               */
              reset: function() {
                this.xPos[0] = 0;
                this.xPos[1] = HorizonLine.dimensions.WIDTH;
              }
            };
            //******************************************************************************
            /**
             * Horizon background class.
             * @param {HTMLCanvasElement} canvas
             * @param {Object} spritePos Sprite positioning.
             * @param {Object} dimensions Canvas dimensions.
             * @param {number} gapCoefficient
             * @constructor
             */
            function Horizon(canvas, spritePos, dimensions, gapCoefficient) {
              this.canvas = canvas;
              this.canvasCtx = this.canvas.getContext('2d');
              this.config = Horizon.config;
              this.dimensions = dimensions;
              this.gapCoefficient = gapCoefficient;
              this.obstacles = [];
              this.obstacleHistory = [];
              this.horizonOffsets = [0, 0];
              this.cloudFrequency = this.config.CLOUD_FREQUENCY;
              this.spritePos = spritePos;
              this.nightMode = null;
              // Cloud
              this.clouds = [];
              this.cloudSpeed = this.config.BG_CLOUD_SPEED;
              // Horizon
              this.horizonLine = null;
              this.init();
            };
            /**
             * Horizon config.
             * @enum {number}
             */
            Horizon.config = {
              BG_CLOUD_SPEED: 0.2,
              BUMPY_THRESHOLD: .3,
              CLOUD_FREQUENCY: .5,
              HORIZON_HEIGHT: 16,
              MAX_CLOUDS: 6
            };
            Horizon.prototype = {
              /**
               * Initialise the horizon. Just add the line and a cloud. No obstacles.
               */
              init: function() {
                this.addCloud();
                this.horizonLine = new HorizonLine(this.canvas, this.spritePos.HORIZON);
                this.nightMode = new NightMode(this.canvas, this.spritePos.MOON,
                    this.dimensions.WIDTH);
              },
              /**
               * @param {number} deltaTime
               * @param {number} currentSpeed
               * @param {boolean} updateObstacles Used as an override to prevent
               *     the obstacles from being updated / added. This happens in the
               *     ease in section.
               * @param {boolean} showNightMode Night mode activated.
               */
              update: function(deltaTime, currentSpeed, updateObstacles, showNightMode) {
                this.runningTime += deltaTime;
                this.horizonLine.update(deltaTime, currentSpeed);
                this.nightMode.update(showNightMode);
                this.updateClouds(deltaTime, currentSpeed);
                if (updateObstacles) {
                  this.updateObstacles(deltaTime, currentSpeed);
                }
              },
              /**
               * Update the cloud positions.
               * @param {number} deltaTime
               * @param {number} currentSpeed
               */
              updateClouds: function(deltaTime, speed) {
                var cloudSpeed = this.cloudSpeed / 1000 * deltaTime * speed;
                var numClouds = this.clouds.length;
                if (numClouds) {
                  for (var i = numClouds - 1; i >= 0; i--) {
                    this.clouds[i].update(cloudSpeed);
                  }
                  var lastCloud = this.clouds[numClouds - 1];
                  // Check for adding a new cloud.
                  if (numClouds < this.config.MAX_CLOUDS &&
                      (this.dimensions.WIDTH - lastCloud.xPos) > lastCloud.cloudGap &&
                      this.cloudFrequency > Math.random()) {
                    this.addCloud();
                  }
                  // Remove expired clouds.
                  this.clouds = this.clouds.filter(function(obj) {
                    return !obj.remove;
                  });
                } else {
                  this.addCloud();
                }
              },
              /**
               * Update the obstacle positions.
               * @param {number} deltaTime
               * @param {number} currentSpeed
               */
              updateObstacles: function(deltaTime, currentSpeed) {
                // Obstacles, move to Horizon layer.
                var updatedObstacles = this.obstacles.slice(0);
                for (var i = 0; i < this.obstacles.length; i++) {
                  var obstacle = this.obstacles[i];
                  obstacle.update(deltaTime, currentSpeed);
                  // Clean up existing obstacles.
                  if (obstacle.remove) {
                    updatedObstacles.shift();
                  }
                }
                this.obstacles = updatedObstacles;
                if (this.obstacles.length > 0) {
                  var lastObstacle = this.obstacles[this.obstacles.length - 1];
                  if (lastObstacle && !lastObstacle.followingObstacleCreated &&
                      lastObstacle.isVisible() &&
                      (lastObstacle.xPos + lastObstacle.width + lastObstacle.gap) <
                      this.dimensions.WIDTH) {
                    this.addNewObstacle(currentSpeed);
                    lastObstacle.followingObstacleCreated = true;
                  }
                } else {
                  // Create new obstacles.
                  this.addNewObstacle(currentSpeed);
                }
              },
              removeFirstObstacle: function() {
                this.obstacles.shift();
              },
              /**
               * Add a new obstacle.
               * @param {number} currentSpeed
               */
              addNewObstacle: function(currentSpeed) {
                var obstacleTypeIndex = getRandomNum(0, Obstacle.types.length - 1);
                var obstacleType = Obstacle.types[obstacleTypeIndex];
                // Check for multiples of the same type of obstacle.
                // Also check obstacle is available at current speed.
                if (this.duplicateObstacleCheck(obstacleType.type) ||
                    currentSpeed < obstacleType.minSpeed) {
                  this.addNewObstacle(currentSpeed);
                } else {
                  var obstacleSpritePos = this.spritePos[obstacleType.type];
                  this.obstacles.push(new Obstacle(this.canvasCtx, obstacleType,
                      obstacleSpritePos, this.dimensions,
                      this.gapCoefficient, currentSpeed, obstacleType.width));
                  this.obstacleHistory.unshift(obstacleType.type);
                  if (this.obstacleHistory.length > 1) {
                    this.obstacleHistory.splice(Runner.config.MAX_OBSTACLE_DUPLICATION);
                  }
                }
              },
              /**
               * Returns whether the previous two obstacles are the same as the next one.
               * Maximum duplication is set in config value MAX_OBSTACLE_DUPLICATION.
               * @return {boolean}
               */
              duplicateObstacleCheck: function(nextObstacleType) {
                var duplicateCount = 0;
                for (var i = 0; i < this.obstacleHistory.length; i++) {
                  duplicateCount = this.obstacleHistory[i] == nextObstacleType ?
                      duplicateCount + 1 : 0;
                }
                return duplicateCount >= Runner.config.MAX_OBSTACLE_DUPLICATION;
              },
              /**
               * Reset the horizon layer.
               * Remove existing obstacles and reposition the horizon line.
               */
              reset: function() {
                this.obstacles = [];
                this.horizonLine.reset();
                this.nightMode.reset();
              },
              /**
               * Update the canvas width and scaling.
               * @param {number} width Canvas width.
               * @param {number} height Canvas height.
               */
              resize: function(width, height) {
                this.canvas.width = width;
                this.canvas.height = height;
              },
              /**
               * Add a new cloud to the horizon.
               */
              addCloud: function() {
                this.clouds.push(new Cloud(this.canvas, this.spritePos.CLOUD,
                    this.dimensions.WIDTH));
              }
            };
            })();
        </script>
            <script type="text/javascript">
             	var game = new Runner('.interstitial-wrapper');
            </script>
</div>
</body></html>
